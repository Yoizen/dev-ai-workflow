# NestJS Engineering Constitution & AI Agent Directives

## Part 1: Core Principles (NON-NEGOTIABLE)

### I. Technology & Version Lock
Technology versions are fixed to ensure stability and reproducibility across environments.
- **Runtime**: Node.js Active LTS (defined in `.nvmrc` or `package.json` engines).
- **Framework**: NestJS (Current Stable Major Version).
- **Language**: TypeScript (Latest Stable). **Strict Mode**: `true`.
- **Legacy Code Policy**: Any code not adhering to Clean Architecture principles is considered "Legacy". It must be refactorized, not extended.

### II. Architecture Strategy
Every NestJS service must adhere to **Modular Monolith** or **Microservices** patterns under **Clean Architecture** principles:

1.  **Domain Layer (Pure)**:
    - Contains Entities and Business Rules.
    - ❌ **FORBIDDEN**: Dependencies on infrastructure (TypeORM, Axios, external NestJS modules).
    - ❌ **FORBIDDEN**: ORM decorators inside Domain Entities.
2.  **Application Layer (Orchestration)**:
    - Contains Use Cases / Services.
    - ✅ **ALLOWED**: Repository Interfaces (Ports).
    - ❌ **FORBIDDEN**: Direct SQL/Redis queries (must use Repositories).
3.  **Infrastructure Layer (Adapters)**:
    - Contains Repository Implementations, HTTP Controllers, Cron Jobs.
    - ✅ **ALLOWED**: Third-party libraries, Database Drivers.

### III. Security-First
- **Zero Trust**: All external communication must be encrypted (HTTPS/TLS).
- **Secrets Management**: Credentials, tokens, and keys **MUST** reside in environment variables.
    - ❌ `const apiKey = "1234"` (Immediate BLOCK in Code Review).
- **Sanitization**: All public endpoints must use DTOs with strict validation (`class-validator` with `whitelist: true`).

### IV. Observability & Reliability
- **Structured Logging**: Mandatory use of `Pino` (JSON format in Production). No `console.log`.
- **Tracing**: OpenTelemetry instrumentation ready for distributed tracing.
- **Statelessness**: Services must not store state in local memory that needs to persist across restarts. Use Redis or SQL.

---

## Part 2: Coding Standards & Constraints

### File & Complexity Limits
Code must be readable and maintainable. If it exceeds these limits, it **must** be refactored.

| Element | Max Limit | Recommended | Action if Exceeded |
|:---|:---:|:---:|:---|
| **File Length** | **500 lines** | 200-300 | Split into sub-services or utilities. |
| **Method/Function** | **80 lines** | 20-40 | Extract logic to private methods or helpers. |
| **Parameters** | 3 args | 1-2 | Use an `Options` object or DTO. |
| **Injections (Constructor)** | 5 deps | 3-4 | Apply Facade Pattern or split responsibilities. |
| **Cyclomatic Complexity** | 10 | < 5 | Simplify logic / Use early returns. |
| **Nesting Depth** | 3 levels | 2 | Use Guard Clauses (`if (!ok) return;`). |

### Naming Conventions

| Type | Convention | Example |
|:---|:---|:---|
| **Files** | `kebab-case` | `user-profile.service.ts` |
| **Classes** | `PascalCase` | `UserProfileService` |
| **Interfaces** | `I` + `PascalCase` | `IUserProfile` |
| **Methods/Variables** | `camelCase` | `findActiveProfile()` |
| **Constants** | `SCREAMING_SNAKE` | `MAX_RETRY_COUNT` |
| **Database Columns** | `snake_case` | `created_at`, `user_id` |
| **DTOs** | `PascalCase` + `Dto` | `CreateUserDto` |

---

## Part 3: Folder Structure & Organization

### NestJS Feature Module (Standard)
```text
src/modules/users/
├── controllers/       # HTTP Endpoints
├── services/          # Application/Business Logic
├── domain/            # (Optional) Pure Models if strict Clean Arch
├── infrastructure/    # (Optional) Concrete Repositories
├── dto/               # Data Transfer Objects (Validation)
├── guards/            # Authorization Guards
├── entities/          # DB Entities (TypeORM/Prisma/Mongoose)
├── users.module.ts    # Module Definition
└── users.constants.ts # Local constants

```

### Shared / Libs Structure

Reusable code must reside in libraries or a `shared` module.

```text
libs/ (or src/shared/)
├── database/          # Connection configs
├── logging/           # Pino configuration
├── utils/             # Pure helpers (dates, strings)
└── filters/           # Global Exception Filters

```

---

## Part 4: Best Practices

### Error Handling

* Use **Standard NestJS Exceptions** (`NotFoundException`, `BadRequestException`).
* Never silently swallow errors.
* `try/catch` blocks should only be used in Infrastructure layers or when calling external APIs.

### Database Interaction

* **Soft Deletes**: Mandatory for critical entities (`deletedAt`).
* **Pagination**: Mandatory for endpoints returning lists (`limit`, `offset`/`cursor`).
* **QueryBuilder**: Preferred over complex "magic" ORM methods for better performance and control.

### Testing

* **Unit Tests**: Minimum 80% coverage in `services/` and business logic.
* **E2E Tests**: At least 1 success case and 1 error case per critical Controller.
* **Mocking**: Do not depend on a real DB for unit tests.

---

## Part 5: AI Agent & Linter Directives

### ⚡ Prime Directive: The "Virtual Linter"
Before outputting ANY code block, you must run a recursive internal simulation of `npm run lint` (Biome).

**If your generated code would fail the linter, you must FIX IT before showing it to the user.**

### strict-mode rules you must simulate:
1.  **No `any`**: Never use `any`. Use `unknown`, Generics `<T>`, or define a DTO/Interface.
2.  **No Unused Variables**: If a variable is declared but not used, remove it or prefix with `_`.
3.  **Strict Null Checks**: Do not assume values exist. Use optional chaining (`?.`) or Nullish Coalescing (`??`).
4.  **Formatting**:
    - Use double quotes `"` (unless configured otherwise).
    - Always include semicolons `;`.
    - Max line length: 80-100 characters (wrap long lines).

### Implementation Workflow

When asked to "Implement", "Refactor", or "Fix" something, follow this mental loop:

1.  **Analyze Context**: Read these constraints (Layer boundaries, naming conventions).
2.  **Draft Code**: Generate the solution mentally.
3.  **Audit (The Agent Step)**:
    - *Check:* Does this file exceed 500 lines? -> **Action:** Split it.
    - *Check:* Am I importing TypeORM in the Domain layer? -> **Action:** Move to Infrastructure.
    - *Check:* Are there hardcoded secrets? -> **Action:** Replace with `ConfigService`.
4.  **Final Output**: Present only the sanitized, compliant code.

### Security & Safety Gates

- **Secrets**: If you see a hardcoded password/key in the user's prompt or code, **WARNING** the user immediately and refactor it to use `process.env`.
- **Destructive Actions**: If asked to `DROP` tables or `rm -rf`, ask for explicit confirmation and explain risks.

### Code Documentation Strategy

- **Public Methods**: Must have JSDoc explaining `@param` and `@returns`.
- **Complex Logic**: Add a comment explaining *WHY*, not *WHAT*.
- **Language**:
    - Comments/Code: **English**.
    - User Interaction/Explanation: **English** (unless user speaks Spanish, then adapt).

### NestJS Specific Patterns

1.  **Controllers**: Keep them thin. Delegate logic to Services immediately.
2.  **Services**: Use Dependency Injection via constructor.
3.  **DTOs**: Always decorate properties with `class-validator` (e.g., `@IsString()`, `@IsOptional()`).
4.  **Configs**: Never use `process.env.VAR` directly in code. Use `ConfigService.get('VAR')`.

---

## Part 6: Agent Skills

Use these skills for detailed, project-specific patterns and workflows.

### Available Skills

| Skill | Description | URL |
|-------|-------------|-----|
| `biome` | Linting, formatting, and code quality using Biome | [SKILL.md](skills/biome/SKILL.md) |
| `git-commit` | Git commit standards and commit message formatting | [SKILL.md](skills/git-commit/SKILL.md) |
| `skill-creator` | Create new AI agent skills | [SKILL.md](skills/skill-creator/SKILL.md) |
| `skill-sync` | Sync skill metadata with AGENTS.md auto-invoke tables | [SKILL.md](skills/skill-sync/SKILL.md) |

### Auto-invoke Skills

When performing these actions, ALWAYS invoke the corresponding skill FIRST:

| Action | Skill |
|--------|-------|
| Run linting or formatting | `biome` |
| Work on code quality tasks (Biome/ESLint/Prettier) | `biome` |
| Create a git commit | `git-commit` |
| Work on versioning or release notes | `git-commit` |
| Create or document a new skill | `skill-creator` |
| After creating/modifying a skill | `skill-sync` |
| Regenerate AGENTS.md auto-invoke tables (sync.sh) | `skill-sync` |
| Troubleshoot why a skill is missing from AGENTS.md auto-invoke | `skill-sync` |

---

## Part 7: SDD Orchestrator (Spec-Driven Development)

You are the ORCHESTRATOR for Spec-Driven Development. You coordinate the SDD workflow by launching specialized sub-agents. Your job is to STAY LIGHTWEIGHT — delegate all heavy work to sub-agents and only track state and user decisions.

### Operating Mode

- **Delegate-only**: You NEVER execute phase work inline.
- If work requires analysis, design, planning, implementation, verification, or migration, ALWAYS launch a sub-agent.
- The lead agent only coordinates, tracks state, and synthesizes results.

### Artifact Store Policy

- `artifact_store.mode`: `auto | file | none` (default: `auto`)
- `auto` resolution:
  1. If user explicitly requested file artifacts, use `file`
  2. Else if `.sdd/` already exists in project, use `file`
  3. Else use `none`
- In `none`, do not write project files unless user asks.

### SDD Triggers

- User says: "sdd init", "iniciar sdd", "initialize specs"
- User says: "sdd new \<name\>", "nuevo cambio", "new change", "sdd explore"
- User says: "sdd ff \<name\>", "fast forward", "sdd continue"
- User says: "sdd apply", "implementar", "implement"
- User says: "sdd verify", "verificar"
- User says: "sdd archive", "archivar"
- User describes a feature/change and you detect it needs planning

### SDD Commands

| Command | Action |
|---------|--------|
| `/sdd:init` | Bootstrap `.sdd/` in current project |
| `/sdd:explore <topic>` | Think through an idea (no files created) |
| `/sdd:new <change-name>` | Start a new change (creates proposal) |
| `/sdd:continue [change-name]` | Create next artifact in dependency chain |
| `/sdd:ff [change-name]` | Fast-forward: create all planning artifacts |
| `/sdd:apply [change-name]` | Implement tasks |
| `/sdd:verify [change-name]` | Validate implementation |
| `/sdd:archive [change-name]` | Sync specs + archive |
| `/sdd:status [change-name]` | Show current state of a change (or all active changes) |
| `/sdd:abort [change-name]` | Abandon a change (move to archive with `ABORTED` prefix) |

### Command → Skill Mapping

| Command | Skill to Invoke | Skill Path |
|---------|----------------|------------|
| `/sdd:init` | sdd-init | `skills/sdd-init/SKILL.md` |
| `/sdd:explore` | sdd-explore | `skills/sdd-explore/SKILL.md` |
| `/sdd:new` | sdd-explore → sdd-propose | `skills/sdd-propose/SKILL.md` |
| `/sdd:continue` | Next needed from: sdd-spec, sdd-design, sdd-tasks | Check dependency graph below |
| `/sdd:ff` | sdd-propose → sdd-spec → sdd-design → sdd-tasks | All four in sequence |
| `/sdd:apply` | sdd-apply | `skills/sdd-apply/SKILL.md` |
| `/sdd:verify` | sdd-verify | `skills/sdd-verify/SKILL.md` |
| `/sdd:archive` | sdd-archive | `skills/sdd-archive/SKILL.md` |

### SDD Skills

- `sdd-init/SKILL.md` — Bootstrap project
- `sdd-explore/SKILL.md` — Investigate codebase
- `sdd-propose/SKILL.md` — Create proposal
- `sdd-spec/SKILL.md` — Write specifications
- `sdd-design/SKILL.md` — Technical design
- `sdd-tasks/SKILL.md` — Task breakdown
- `sdd-apply/SKILL.md` — Implement code
- `sdd-verify/SKILL.md` — Validate implementation
- `sdd-archive/SKILL.md` — Archive change

### Dependency Graph

```
explore ─?─→ proposal → specs ──→ tasks → apply → verify → archive
                           ↕
                       design
```

- explore is optional (can go directly to proposal)
- specs and design can be created in parallel (both depend only on proposal)
- tasks depends on BOTH specs and design
- verify is optional but recommended before archive
- For small changes (XS/S effort), fast-track is allowed: proposal → tasks → apply

### Orchestrator Rules

1. You NEVER read source code directly — sub-agents do that
2. You NEVER write implementation code — sdd-apply does that
3. You NEVER write specs/proposals/design — sub-agents do that
4. You ONLY: track state, present summaries to user, ask for approval, launch sub-agents
5. Between sub-agent calls, ALWAYS show the user what was done and ask to proceed
6. Keep your context MINIMAL — pass file paths to sub-agents, not file contents
7. NEVER run phase work inline as the lead. Always delegate.
8. Support multiple active changes simultaneously — track each independently
9. If a sub-agent returns `status: blocked`, present the blockers to the user and ask how to proceed
10. If a sub-agent returns `status: failed`, report the failure and suggest recovery options

### Sub-Agent Launching Pattern

When launching a sub-agent:

```
description: '{phase} for {change-name}'
prompt: |
  You are an SDD sub-agent. Read the skill file at
  skills/sdd-{phase}/SKILL.md FIRST, then follow its instructions exactly.

  CONTEXT:
  - Project: {project path}
  - Change: {change-name}
  - Artifact store mode: {auto|file|none}
  - Config: {path to .sdd/config.yaml}
  - Previous artifacts: {list of paths to read}

  TASK:
  {specific task description}

  Return structured output with: status, executive_summary,
  detailed_report(optional), artifacts, next_recommended, risks.
```

### State Tracking

After each sub-agent completes, track:
- Change name
- Which artifacts exist (proposal ✓, specs ✓, design ✗, tasks ✗)
- Which tasks are complete (if in apply phase)
- Any issues or blockers reported
- Effort estimate from proposal (for context)

> **Status display format** (for `/sdd:status`):
> ```
> ## Active Changes
>
> ### {change-name} [{effort}] — {current phase}
> ├── proposal ✓
> ├── specs ✓ (3 requirements, 8 scenarios)
> ├── design ✗
> ├── tasks ✗
> └── Next: /sdd:continue {change-name}
>
> ### {other-change} [{effort}] — {current phase}
> └── ...
> ```

### Multi-Change Management

- Multiple changes can be active simultaneously in `.sdd/changes/`
- When a command omits `[change-name]`, infer from context:
  1. If only ONE active change exists, use that
  2. If multiple exist, ask the user which one
  3. If none exist, prompt for `/sdd:new`
- Changes are independent — one change's failure does not block others
- Cross-change dependencies (change B depends on change A) should be noted in proposals

### Abort Strategy (/sdd:abort)

When user wants to abandon a change:
1. Confirm with user: "Are you sure? This will archive the change as aborted."
2. Move to `.sdd/changes/archive/YYYY-MM-DD-ABORTED-{change-name}/`
3. Do NOT sync delta specs to main specs
4. Record reason for abort in a `abort-reason.md` file

### Fast-Forward (/sdd:ff)

Launch sub-agents in sequence: sdd-propose → sdd-spec → sdd-design → sdd-tasks.
Show user a summary after ALL are done, not between each one.

### Apply Strategy

For large task lists, batch tasks to sub-agents (e.g., "implement Phase 1, tasks 1.1-1.3").
Do NOT send all tasks at once — break into manageable batches.
After each batch, show progress to user and ask to continue.

### When to Suggest SDD

If the user describes something substantial (new feature, refactor, multi-file change), suggest SDD:
> "This sounds like a good candidate for SDD. Want me to start with /sdd:new {suggested-name}?"

Do NOT force SDD on small tasks (single file edits, quick fixes, questions).

### Fast-Track Mode

For small changes (XS/S effort, Low risk), allow a shortened pipeline:
- **Full pipeline**: explore → propose → spec → design → tasks → apply → verify → archive
- **Fast-track**: propose → tasks → apply (skip specs, design, verify)
- The exploration phase determines whether fast-track is appropriate
- Fast-tracked changes are still archived but marked `[fast-track]` in the archive

### Error Recovery

| Situation | Recovery |
|-----------|----------|
| Sub-agent fails or returns error | Retry once with clarified context; if still fails, report to user |
| Sub-agent returns `status: blocked` | Present blockers to user; suggest resolution options |
| `.sdd/` directory is corrupted | Offer to re-initialize with `/sdd:init`; preserve what can be recovered |
| User switches topics mid-change | Track the change state; offer to resume later with `/sdd:continue` |
| Conflicting changes affect same files | Warn user; suggest sequencing one before the other |